# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strong
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/skylight-core/all/skylight-core.rbi
#
# skylight-core-4.1.2
module Skylight
end
module Skylight::Core
end
class Skylight::Core::Deprecation < ActiveSupport::Deprecation
  def self.ignored_callstack(*args, &block); end
  def self.instance; end
end
module Skylight::Core::Util
end
class Skylight::Core::Util::AlertLogger
  def close; end
  def initialize(logger); end
  def write(*args); end
end
module Skylight::Core::Util::Logging
  def config_for_logging; end
  def debug(msg, *args); end
  def error(msg, *args); end
  def fmt(*args); end
  def info(msg, *args); end
  def log(level, msg, *args); end
  def log_context; end
  def log_debug(msg, *args); end
  def log_env_prefix; end
  def log_error(msg, *args); end
  def log_info(msg, *args); end
  def log_trace(msg, *args); end
  def log_warn(msg, *args); end
  def raise_on_error?; end
  def t; end
  def trace(msg, *args); end
  def trace?; end
  def warn(msg, *args); end
end
module Skylight::Core::Util::Proxy
  def self.detect_url(env); end
end
class Skylight::Core::ConfigError < RuntimeError
end
class Skylight::Core::Config
  def [](key, default = nil); end
  def []=(key, val, scope = nil); end
  def alert_logger; end
  def alert_logger=(arg0); end
  def as_json(*arg0); end
  def cast_for_env(val); end
  def check_file_permissions(file, key); end
  def check_logfile_permissions(log_file, key); end
  def create_logger(out); end
  def duration_ms(key, default = nil); end
  def enable_segments?; end
  def enable_sidekiq?; end
  def environment; end
  def gc; end
  def get(key, default = nil); end
  def ignored_endpoints; end
  def initialize(*args); end
  def key?(key); end
  def load_logger; end
  def logger; end
  def logger=(arg0); end
  def on_heroku?; end
  def root; end
  def self.default_values; end
  def self.env_matcher; end
  def self.env_prefix; end
  def self.env_to_key; end
  def self.legacy_keys; end
  def self.load(opts = nil, env = nil); end
  def self.log_name; end
  def self.native_env_keys; end
  def self.remap_env(env); end
  def self.remap_key(key); end
  def self.required_keys; end
  def self.server_validated_keys; end
  def self.service_name; end
  def self.support_email; end
  def self.validators; end
  def send_or_get(val); end
  def set(key, val, scope = nil); end
  def to_json(*arg0); end
  def to_native_env; end
  def user_config; end
  def validate!; end
  def validate_with_server; end
  def version; end
  def write(_path); end
  include Skylight::Core::Util::Logging
end
class Skylight::Core::UserConfig
  def disable_dev_warning; end
  def disable_dev_warning=(arg0); end
  def disable_dev_warning?; end
  def disable_env_warning; end
  def disable_env_warning=(arg0); end
  def disable_env_warning?; end
  def file_path; end
  def initialize(config); end
  def reload; end
  def save; end
  def to_hash; end
end
class Skylight::Core::GC
  def __update; end
  def config; end
  def enable; end
  def initialize(config, profiler); end
  def release(win); end
  def total_time; end
  def track; end
  def update; end
  include Skylight::Core::Util::Logging
end
class Skylight::Core::GC::Window
  def add(time); end
  def initialize(global); end
  def release; end
  def time; end
  def update; end
end
class Skylight::Core::Instrumenter
  def broken!; end
  def check_install!; end
  def config; end
  def current_trace; end
  def current_trace=(trace); end
  def disable; end
  def disabled?; end
  def done(span, meta = nil); end
  def finalize_endpoint_segment(trace); end
  def gc; end
  def ignore?(trace); end
  def initialize(uuid, config); end
  def instrument(cat, title = nil, desc = nil, meta = nil); end
  def limited_description(description); end
  def log_context; end
  def match?(string, regex); end
  def native_start; end
  def native_stop; end
  def native_submit_trace(_trace); end
  def native_track_desc(_endpoint, _description); end
  def process(trace); end
  def process_sql(sql); end
  def self.match?(string, regex); end
  def self.native_new(_uuid, _config_env); end
  def self.new(config); end
  def self.trace_class; end
  def shutdown; end
  def span_correlation_header(span); end
  def start!; end
  def trace(endpoint, cat, title = nil, desc = nil, meta: nil, segment: nil); end
  def trace_info; end
  def uuid; end
  include Skylight::Core::Util::Logging
end
class Skylight::Core::Instrumenter::TraceInfo
  def current; end
  def current=(trace); end
  def initialize(key = nil); end
end
module Skylight::Core::Fanout
  def self.broken!; end
  def self.done(spans, meta = nil); end
  def self.each_trace; end
  def self.endpoint=(endpoint); end
  def self.instrument(*args); end
  def self.register(obj); end
  def self.registered; end
  def self.trace(*args); end
  def self.unregister(obj); end
end
class Skylight::Core::Trace
  def broken!; end
  def broken?; end
  def config; end
  def deferred_spans; end
  def done(span, meta = nil); end
  def endpoint; end
  def endpoint=(value); end
  def gc_time; end
  def handle_unexpected_stop(expected, span); end
  def initialize(instrumenter, cat, title, desc, meta); end
  def inspect; end
  def instrument(cat, title = nil, desc = nil, meta = nil); end
  def instrumenter; end
  def log_context; end
  def maybe_broken(err); end
  def meta; end
  def normalized_stop(span, time); end
  def notifications; end
  def record(cat, title = nil, desc = nil); end
  def release; end
  def segment; end
  def segment=(arg0); end
  def self.new(instrumenter, endpoint, start, cat, title = nil, desc = nil, meta: nil, segment: nil); end
  def self.normalize_time(time); end
  def span_correlation_header(span); end
  def start(time, cat, title, desc, meta, opts = nil); end
  def stop(span, time); end
  def submit; end
  def traced; end
  def track_gc(time, now); end
  def uuid; end
  def uuid=(arg0); end
  include Skylight::Core::Util::Logging
end
module Skylight::Core::VM
end
class Skylight::Core::VM::GC
  def enable; end
  def initialize; end
  def total_time; end
end
module Skylight::Core::Util::AllocationFree
  def array_find(array); end
end
class Skylight::Core::Util::Clock
  def absolute_secs; end
  def nanos; end
  def secs; end
  def self.absolute_secs; end
  def self.default; end
  def self.default=(arg0); end
  def self.nanos; end
  def self.secs; end
  def self.use_native!; end
  def tick; end
end
class Skylight::Core::Middleware
  def call(env); end
  def config; end
  def endpoint_meta(_env); end
  def endpoint_name(_env); end
  def initialize(app, opts = nil); end
  def instrumentable; end
  def internal_request_id; end
  def log_context; end
  def make_request_id(request_id); end
  def self.with_after_close(resp, &block); end
  def set_request_id(env); end
  include Skylight::Core::Util::Logging
end
class Skylight::Core::Middleware::BodyProxy
  def close; end
  def closed?; end
  def each(*args, &block); end
  def initialize(body, &block); end
  def method_missing(*args, &block); end
  def respond_to_missing?(*args); end
end
module Skylight::Core::Sidekiq
  def self.add_middleware(instrumentable); end
end
class Skylight::Core::Sidekiq::ServerMiddleware
  def call(_worker, job, queue); end
  def initialize(instrumentable); end
  include Skylight::Core::Util::Logging
end
class Skylight::Core::Subscriber
  def _start(trace, name, payload); end
  def config; end
  def finish(name, _id, payload); end
  def initialize(config, instrumenter); end
  def normalize(*args); end
  def normalize_after(*args); end
  def normalizers; end
  def publish(name, *args); end
  def register!; end
  def start(name, _id, payload); end
  def unregister!; end
  include Skylight::Core::Util::Logging
end
class Skylight::Core::Subscriber::Notification
  def initialize(name, span); end
  def name; end
  def span; end
end
module Skylight::Core::Instrumentable
  def self.included(base); end
end
module Skylight::Core::Instrumentable::ClassMethods
  def broken!; end
  def config; end
  def correlation_header; end
  def disable; end
  def done(span, meta = nil); end
  def enable_normalizer(*names); end
  def instrument(opts = nil, &block); end
  def instrumenter; end
  def instrumenter_class; end
  def probe(*args); end
  def span_correlation_header(span); end
  def start!(config = nil); end
  def started?; end
  def stop!; end
  def trace(endpoint = nil, cat = nil, title = nil, meta: nil, segment: nil); end
  def tracing?; end
end
module Skylight::Core::Probes
  def self.add_path(path); end
  def self.available; end
  def self.available?(klass_name); end
  def self.installed; end
  def self.lookup_by_require_path(require_path); end
  def self.paths; end
  def self.probe(*probes); end
  def self.register(name, *args); end
  def self.register_require_hook(registration); end
  def self.require_hook(require_path); end
  def self.require_hooks; end
  def self.unregister_require_hook(registration); end
end
class Skylight::Core::Probes::ProbeRegistration
  def initialize(name, klass_name, require_paths, probe); end
  def install; end
  def klass_name; end
  def name; end
  def probe; end
  def require_paths; end
end
module Kernel
  def require_without_sk(path); end
end
module Skylight::Core::Util::Gzip
  def self.compress(str); end
end
module Skylight::Core::Railtie
  def activate?(_sk_config); end
  def config_path(app); end
  def configure_logging(config, app); end
  def development_warning; end
  def environments; end
  def existent_paths(paths); end
  def insert_middleware(app, config); end
  def load_probes; end
  def load_skylight_config(app); end
  def log_prefix; end
  def log_warning(config, msg); end
  def middleware_position; end
  def run_initializer(app); end
  def set_middleware_position(app, config); end
  def sk_rails_config(target = nil); end
  extend ActiveSupport::Concern
end
